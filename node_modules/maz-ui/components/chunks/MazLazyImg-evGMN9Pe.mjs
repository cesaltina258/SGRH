var u = Object.defineProperty;
var f = (a, e, t) => e in a ? u(a, e, { enumerable: !0, configurable: !0, writable: !0, value: t }) : a[e] = t;
var i = (a, e, t) => (f(a, typeof e != "symbol" ? e + "" : e, t), t);
import "../assets/MazLazyImg.css";
import { defineComponent as v, defineAsyncComponent as A, computed as p, withDirectives as y, openBlock as d, createElementBlock as c, normalizeClass as I, normalizeStyle as b, Fragment as C, renderList as E, createElementVNode as O, mergeProps as L, createVNode as z, unref as h, createCommentVNode as P, renderSlot as S } from "vue";
import { _ as w } from "./MazAvatar-0JzIvOc4.mjs";
const B = "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7", H = {
  baseClass: "m-lazy-img",
  loadedClass: "m-lazy-loaded",
  loadingClass: "m-lazy-loading",
  errorClass: "m-lazy-error",
  noPhotoClass: "m-lazy-no-photo",
  noPhoto: !1,
  observerOnce: !0,
  loadOnce: !1,
  noUseErrorPhoto: !1,
  observerOptions: {
    threshold: 0.1
  }
};
class M {
  constructor(e = {}) {
    i(this, "observers", []);
    i(this, "defaultOptions", H);
    i(this, "options");
    i(this, "onImgLoadedCallback");
    i(this, "onImgErrorCallback");
    i(this, "hasImgLoaded", !1);
    this.options = this.buildOptions(e), this.onImgLoadedCallback = this.imageIsLoaded.bind(this), this.onImgErrorCallback = this.imageHasError.bind(this);
  }
  async loadErrorPhoto() {
    const { default: e } = await import("./no-photography-1qnDtpgo.mjs");
    return e;
  }
  buildOptions(e) {
    return {
      ...this.defaultOptions,
      ...e,
      observerOptions: {
        ...this.defaultOptions.observerOptions,
        ...e.observerOptions
      }
    };
  }
  removeClass(e, t) {
    e.classList.remove(t);
  }
  addClass(e, t) {
    e.classList.add(t);
  }
  removeAllStateClasses(e) {
    this.removeClass(e, this.options.loadedClass), this.removeClass(e, this.options.loadingClass), this.removeClass(e, this.options.errorClass), this.removeClass(e, this.options.noPhotoClass);
  }
  setBaseClass(e) {
    this.addClass(e, this.options.baseClass);
  }
  imageIsLoading(e) {
    var t, s;
    this.addClass(e, this.options.loadingClass), (s = (t = this.options).onLoading) == null || s.call(t, e);
  }
  imageHasNoPhoto(e) {
    this.removeClass(e, this.options.loadingClass), this.addClass(e, this.options.noPhotoClass), this.setDefaultPhoto(e);
  }
  imageIsLoaded(e) {
    var t, s;
    this.hasImgLoaded = !0, this.removeClass(e, this.options.loadingClass), this.addClass(e, this.options.loadedClass), (s = (t = this.options).onLoaded) == null || s.call(t, e);
  }
  imageHasError(e, t) {
    var s, o;
    console.warn("[maz-ui][MazLazyImg] Error while loading image", t), this.removeClass(e, this.options.loadingClass), this.addClass(e, this.options.errorClass), (o = (s = this.options).onError) == null || o.call(s, e), this.setDefaultPhoto(e);
  }
  getImageUrl(e, t) {
    const s = this.getImgElement(e).getAttribute("data-lazy-src");
    if (s)
      return s;
    t.value;
    const o = typeof t.value == "object" ? t.value.src : t.value;
    return o || console.warn("[maz-ui][MazLazyImg] src url is not defined"), o;
  }
  async setPictureSourceUrls(e) {
    const t = e.querySelectorAll("source");
    if (t.length > 0)
      for await (const s of t) {
        const o = s.getAttribute("data-lazy-srcset");
        o ? s.srcset = o : console.warn(
          '[maz-ui][MazLazyImg] the "[data-lazy-srcset]" attribute is not provided on "<source />"'
        );
      }
    else
      console.warn(
        '[maz-ui][MazLazyImg] No "<source />" elements provided into the "<picture />" element'
      ), this.imageHasError(e);
  }
  hasBgImgMode(e) {
    return e.arg === "bg-image";
  }
  isPictureElement(e) {
    return e instanceof HTMLPictureElement;
  }
  getImgElement(e) {
    return this.isPictureElement(e) ? e.querySelector("img") : e;
  }
  async setDefaultPhoto(e) {
    if (this.options.noUseErrorPhoto)
      return;
    const t = this.options.errorPhoto ?? await this.loadErrorPhoto(), s = e.querySelectorAll("source");
    if (s.length > 0)
      for await (const o of s)
        o.srcset = t;
    else
      this.setImgSrc(e, t);
  }
  addEventListenerToImg(e) {
    const t = this.getImgElement(e);
    t.addEventListener("load", () => this.onImgLoadedCallback(e), {
      once: !0
    }), t.addEventListener("error", (s) => this.onImgErrorCallback(e, s), { once: !0 });
  }
  async loadImage(e, t) {
    if (this.imageIsLoading(e), this.isPictureElement(e))
      this.addEventListenerToImg(e), await this.setPictureSourceUrls(e);
    else {
      const s = this.getImageUrl(e, t);
      if (!s)
        return this.imageHasError(e);
      this.hasBgImgMode(t) ? (e.style.backgroundImage = `url('${s}')`, this.imageIsLoaded(e)) : (this.addEventListenerToImg(e), this.setImgSrc(e, s));
    }
  }
  setImgSrc(e, t) {
    const s = this.getImgElement(e);
    s.src = t;
  }
  handleIntersectionObserver(e, t, s, o) {
    var l, r;
    this.observers.push(o);
    for (const n of s)
      if (n.isIntersecting) {
        if ((r = (l = this.options).onIntersecting) == null || r.call(l, n.target), this.options.observerOnce && o.unobserve(e), this.options.loadOnce && this.hasImgLoaded)
          return;
        this.loadImage(e, t);
      }
  }
  createObserver(e, t) {
    const s = (r, n) => {
      this.handleIntersectionObserver(e, t, r, n);
    }, o = this.options.observerOptions;
    new IntersectionObserver(s, o).observe(e);
  }
  async imageHandler(e, t, s) {
    if (s === "update")
      for await (const o of this.observers)
        o.unobserve(e);
    window.IntersectionObserver ? this.createObserver(e, t) : this.loadImage(e, t);
  }
  async bindUpdateHandler(e, t, s) {
    if (this.options.noPhoto)
      return this.imageHasNoPhoto(e);
    await this.imageHandler(e, t, s);
  }
  async add(e, t) {
    if (this.hasBgImgMode(t) && this.isPictureElement(e))
      throw new Error(`[MazLazyImg] You can't use the "bg-image" mode with "<picture />" element`);
    setTimeout(() => this.setBaseClass(e), 0), e.getAttribute("src") || this.setImgSrc(e, B), await this.bindUpdateHandler(e, t, "bind");
  }
  async update(e, t) {
    t.value !== t.oldValue && (this.hasImgLoaded = !1, this.removeAllStateClasses(e), await this.bindUpdateHandler(e, t, "update"));
  }
  remove(e, t) {
    this.hasImgLoaded = !1, this.hasBgImgMode(t) && (e.style.backgroundImage = ""), this.removeAllStateClasses(e);
    for (const s of this.observers)
      s.unobserve(e);
    this.observers = [];
  }
}
let m;
const k = {
  created(a, e) {
    const t = typeof e.value == "object" ? e.value : {};
    m = new M(t), m.add(a, e);
  },
  updated(a, e) {
    m.update(a, e);
  },
  unmounted(a, e) {
    m.remove(a, e);
  }
}, U = ["data-lazy-srcset", "media"], T = ["alt"], D = {
  key: 0,
  class: "m-lazy-img-component-loader"
}, N = /* @__PURE__ */ v({
  inheritAttrs: !1,
  __name: "MazLazyImg",
  props: {
    style: {
      type: [String, Array, Object],
      default: void 0
    },
    class: {
      type: [String, Array, Object],
      default: void 0
    },
    image: { type: [String, Object], default: void 0 },
    alt: { type: String, default: void 0 },
    noPhoto: { type: Boolean, default: !1 },
    noLoader: { type: Boolean, default: !1 },
    noObserverOnce: { type: Boolean, default: !1 },
    loadOnce: { type: Boolean, default: !1 },
    imageHeightFull: { type: Boolean, default: !1 },
    observerOptions: {
      type: Object,
      default: null
    }
  },
  emits: ["intersecting", "loading", "loaded", "error"],
  setup(a) {
    const e = A(() => import("./MazSpinner-J65FS2NQ.mjs")), t = a, s = p(() => {
      var o;
      return typeof t.image == "string" ? [{ srcset: t.image }] : (o = t.image) == null ? void 0 : o.sources;
    });
    return (o, l) => y((d(), c(
      "picture",
      {
        class: I(["m-lazy-img-component", [{ "-use-loader": !a.noLoader, "--height-full": a.imageHeightFull }, t.class]]),
        style: b(a.style)
      },
      [
        (d(!0), c(
          C,
          null,
          E(s.value, ({ srcset: r, media: n }, g) => (d(), c("source", {
            key: g,
            "data-lazy-srcset": r,
            media: n
          }, null, 8, U))),
          128
          /* KEYED_FRAGMENT */
        )),
        O("img", L(o.$attrs, {
          src: "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7",
          loading: "lazy",
          alt: a.alt
        }), null, 16, T),
        a.noLoader ? P("v-if", !0) : (d(), c("div", D, [
          z(h(e), { size: "2em" })
        ])),
        S(o.$slots, "default", {}, void 0, !0)
      ],
      6
      /* CLASS, STYLE */
    )), [
      [h(k), {
        noPhoto: a.noPhoto,
        observerOnce: !a.noObserverOnce,
        loadOnce: a.loadOnce,
        onIntersecting: (r) => o.$emit("intersecting", r),
        onLoading: (r) => o.$emit("loading", r),
        onLoaded: (r) => o.$emit("loaded", r),
        onError: (r) => o.$emit("error", r),
        observerOptions: a.observerOptions
      }]
    ]);
  }
}), V = /* @__PURE__ */ w(N, [["__scopeId", "data-v-df696858"]]);
export {
  V as default
};
