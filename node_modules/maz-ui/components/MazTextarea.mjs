var k = Object.defineProperty;
var L = (t, r, e) => r in t ? k(t, r, { enumerable: !0, configurable: !0, writable: !0, value: e }) : t[r] = e;
var y = (t, r, e) => (L(t, typeof r != "symbol" ? r + "" : r, e), e);
import "./assets/MazTextarea.css";
import { computed as o, defineComponent as q, getCurrentInstance as F, ref as g, onMounted as I, onBeforeUnmount as M, openBlock as m, createElementBlock as f, normalizeClass as z, normalizeStyle as R, createCommentVNode as l, unref as w, createTextVNode as j, toDisplayString as C, withDirectives as N, createElementVNode as O, mergeProps as U, toHandlers as $, vModelText as A } from "vue";
const H = ({
  componentName: t,
  instance: r,
  providedId: e
}) => o(() => e ?? `${t}-${r == null ? void 0 : r.uid}`);
function D(t, r) {
  let e;
  return function(...a) {
    clearTimeout(e), e = setTimeout(() => {
      t.apply(this, a);
    }, r);
  };
}
class P {
  constructor(r) {
    y(this, "element");
    this.element = r, this.onFocus = this.onFocus.bind(this), this.autogrow = this.autogrow.bind(this), this.onResize = D(this.onResize.bind(this), 200), this.connect();
  }
  connect() {
    this.element.addEventListener("focus", this.onFocus), this.element.style.resize = "none", this.element.style.boxSizing = "border-box";
  }
  disconnect() {
    window.removeEventListener("resize", this.onResize), this.element.removeEventListener("input", this.autogrow);
  }
  onFocus() {
    this.autogrow(), this.element.addEventListener("input", this.autogrow), window.addEventListener("resize", this.onResize), this.element.removeEventListener("focus", this.onFocus);
  }
  onResize() {
    this.autogrow();
  }
  autogrow() {
    this.element.style.height = "auto", this.element.style.overflow = "hidden", this.element.style.height = `${this.element.scrollHeight}px`;
  }
}
const G = ["for"], J = { key: 0 }, K = ["id", "name", "disabled", "required"], Q = /* @__PURE__ */ q({
  inheritAttrs: !1,
  __name: "MazTextarea",
  props: {
    style: {
      type: [String, Array, Object],
      default: void 0
    },
    class: {
      type: [String, Array, Object],
      default: void 0
    },
    modelValue: {
      type: String,
      default: void 0
    },
    id: { type: String, default: void 0 },
    name: { type: String, default: "MazTextarea" },
    label: { type: String, default: void 0 },
    required: { type: Boolean, default: !1 },
    disabled: { type: Boolean, default: !1 },
    readonly: { type: Boolean, default: !1 },
    error: { type: Boolean, default: !1 },
    success: { type: Boolean, default: !1 },
    warning: { type: Boolean, default: !1 },
    hint: { type: String, default: void 0 },
    color: {
      type: String,
      default: "primary"
    }
  },
  emits: ["input", "focus", "blur", "change"],
  setup(t, { emit: r }) {
    const e = t, a = r, u = F();
    let s;
    const h = H({
      componentName: "MazTextarea",
      instance: u,
      providedId: e.id
    }), d = g(), i = g(!1), p = o(() => e.modelValue !== void 0 && e.modelValue !== "");
    I(() => {
      d.value && (s = new P(d.value));
    }), M(() => {
      s == null || s.disconnect();
    });
    const b = o({
      get: () => e.modelValue,
      set: (n) => a("input", n)
    }), x = (n) => {
      a("focus", n), i.value = !0;
    }, S = (n) => {
      a("blur", n), i.value = !1;
    }, T = (n) => a("change", n), c = o(() => e.label || e.hint), E = o(() => c.value && (i.value || p.value)), V = o(() => {
      if (e.error)
        return "maz-border-danger";
      if (e.success)
        return "maz-border-success";
      if (e.warning)
        return "maz-border-warning";
      if (i.value) {
        if (e.color === "black")
          return "maz-border-black";
        if (e.color === "danger")
          return "maz-border-danger";
        if (e.color === "info")
          return "maz-border-info";
        if (e.color === "primary")
          return "maz-border-primary";
        if (e.color === "secondary")
          return "maz-border-secondary";
        if (e.color === "success")
          return "maz-border-success";
        if (e.color === "warning")
          return "maz-border-warning";
        if (e.color === "white")
          return "maz-border-white";
      }
      return "--default-border";
    });
    return (n, v) => (m(), f(
      "div",
      {
        class: z(["m-textarea", [
          {
            "--is-disabled": t.disabled,
            "--has-label": c.value
          },
          e.class
        ]]),
        style: R(t.style)
      },
      [
        l(" eslint-disable vuejs-accessibility/label-has-for "),
        c.value ? (m(), f("label", {
          key: 0,
          for: w(h),
          class: z(["m-textarea__label", [
            {
              "maz-text-danger-600": t.error,
              "maz-text-success-600": t.success,
              "maz-text-warning-600": t.warning,
              "--has-state": t.error || t.warning || t.success,
              "--should-up": E.value
            }
          ]])
        }, [
          j(
            C(t.hint || t.label) + " ",
            1
            /* TEXT */
          ),
          t.required ? (m(), f("sup", J, "*")) : l("v-if", !0)
        ], 10, G)) : l("v-if", !0),
        l(" eslint-enable vuejs-accessibility/label-has-for "),
        N(O("textarea", U({
          id: w(h),
          ref_key: "TextareaElement",
          ref: d
        }, n.$attrs, {
          "onUpdate:modelValue": v[0] || (v[0] = (B) => b.value = B),
          name: t.name,
          disabled: t.disabled,
          required: t.required,
          class: [V.value]
        }, $({
          blur: S,
          focus: x,
          change: T
        }, !0)), null, 16, K), [
          [A, b.value]
        ])
      ],
      6
      /* CLASS, STYLE */
    ));
  }
}), W = (t, r) => {
  const e = t.__vccOpts || t;
  for (const [a, u] of r)
    e[a] = u;
  return e;
}, _ = /* @__PURE__ */ W(Q, [["__scopeId", "data-v-f5263337"]]);
export {
  _ as default
};
