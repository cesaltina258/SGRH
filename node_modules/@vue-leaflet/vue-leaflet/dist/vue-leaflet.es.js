import { watch as de, ref as c, provide as G, inject as h, h as z, onUnmounted as se, onBeforeUnmount as J, defineComponent as g, onMounted as O, markRaw as C, nextTick as f, render as Je, reactive as Ke, computed as x } from "vue";
const Qe = (t, o) => {
  for (const e of Object.keys(o))
    t.on(e, o[e]);
}, me = (t) => {
  for (const o of Object.keys(t)) {
    const e = t[o];
    e && U(e.cancel) && e.cancel();
  }
}, Xe = (t) => !t || typeof t.charAt != "function" ? t : t.charAt(0).toUpperCase() + t.slice(1), U = (t) => typeof t == "function", S = (t, o, e) => {
  for (const n in e) {
    const a = "set" + Xe(n);
    t[a] ? de(
      () => e[n],
      (s, l) => {
        t[a](s, l);
      }
    ) : o[a] && de(
      () => e[n],
      (s) => {
        o[a](s);
      }
    );
  }
}, L = (t, o, e = {}) => {
  const n = { ...e };
  for (const a in t) {
    const s = o[a], l = t[a];
    s && (s && s.custom === !0 || l !== void 0 && (n[a] = l));
  }
  return n;
}, T = (t) => {
  const o = {};
  for (const e in t)
    if (e.startsWith("on") && !e.startsWith("onUpdate") && e !== "onReady") {
      const n = e.slice(2).toLocaleLowerCase();
      o[n] = t[e];
    }
  return o;
}, Ye = async (t) => {
  const o = await Promise.all([
    import("leaflet/dist/images/marker-icon-2x.png"),
    import("leaflet/dist/images/marker-icon.png"),
    import("leaflet/dist/images/marker-shadow.png")
  ]);
  delete t.Default.prototype._getIconUrl, t.Default.mergeOptions({
    iconRetinaUrl: o[0].default,
    iconUrl: o[1].default,
    shadowUrl: o[2].default
  });
}, R = (t) => {
  const o = c(
    (...n) => console.warn(`Method ${t} has been invoked without being replaced`)
  ), e = (...n) => o.value(...n);
  return e.wrapped = o, G(t, e), e;
}, ee = (t, o) => t.wrapped.value = o, b = typeof self == "object" && self.self === self && self || typeof global == "object" && global.global === global && global || globalThis, m = (t) => {
  const o = h(t);
  if (!o)
    throw new Error(`Attempt to inject ${t} before it was provided.`);
  return o;
}, j = Symbol(), I = Symbol(), oe = Symbol(), K = Symbol(), ve = Symbol(), be = Symbol(), fe = Symbol(), Le = Symbol(), he = Symbol(), ge = Symbol(), Oe = Symbol(), Se = Symbol(), Q = {
  options: {
    type: Object,
    default: () => ({}),
    custom: !0
  }
}, X = (t) => ({ options: t.options, methods: {} }), Z = {
  ...Q,
  pane: {
    type: String
  },
  attribution: {
    type: String
  },
  name: {
    type: String,
    custom: !0
  },
  layerType: {
    type: String,
    custom: !0
  },
  visible: {
    type: Boolean,
    custom: !0,
    default: !0
  }
}, Y = (t, o, e) => {
  const n = m(I), a = m(oe), { options: s, methods: l } = X(t), r = L(
    t,
    Z,
    s
  ), i = () => n({ leafletObject: o.value }), u = () => a({ leafletObject: o.value }), d = {
    ...l,
    setAttribution(y) {
      u(), o.value.options.attribution = y, t.visible && i();
    },
    setName() {
      u(), t.visible && i();
    },
    setLayerType() {
      u(), t.visible && i();
    },
    setVisible(y) {
      o.value && (y ? i() : u());
    },
    bindPopup(y) {
      if (!o.value || !U(o.value.bindPopup)) {
        console.warn(
          "Attempt to bind popup before bindPopup method available on layer."
        );
        return;
      }
      o.value.bindPopup(y);
    },
    bindTooltip(y) {
      if (!o.value || !U(o.value.bindTooltip)) {
        console.warn(
          "Attempt to bind tooltip before bindTooltip method available on layer."
        );
        return;
      }
      o.value.bindTooltip(y);
    },
    unbindTooltip() {
      o.value && (U(o.value.closeTooltip) && o.value.closeTooltip(), U(o.value.unbindTooltip) && o.value.unbindTooltip());
    },
    unbindPopup() {
      o.value && (U(o.value.closePopup) && o.value.closePopup(), U(o.value.unbindPopup) && o.value.unbindPopup());
    },
    updateVisibleProp(y) {
      e.emit("update:visible", y);
    }
  };
  return G(he, d.bindPopup), G(ge, d.bindTooltip), G(Oe, d.unbindPopup), G(Se, d.unbindTooltip), se(() => {
    d.unbindPopup(), d.unbindTooltip(), u();
  }), { options: r, methods: d };
}, M = (t, o) => {
  if (t && o.default)
    return z("div", { style: { display: "none" } }, o.default());
}, je = {
  ...Z,
  interactive: {
    type: Boolean,
    default: void 0
  },
  bubblingMouseEvents: {
    type: Boolean,
    default: void 0
  }
}, Ve = (t, o, e) => {
  const { options: n, methods: a } = Y(
    t,
    o,
    e
  );
  return { options: L(
    t,
    je,
    n
  ), methods: a };
}, ae = {
  ...je,
  stroke: {
    type: Boolean,
    default: void 0
  },
  color: {
    type: String
  },
  weight: {
    type: Number
  },
  opacity: {
    type: Number
  },
  lineCap: {
    type: String
  },
  lineJoin: {
    type: String
  },
  dashArray: {
    type: String
  },
  dashOffset: {
    type: String
  },
  fill: {
    type: Boolean,
    default: void 0
  },
  fillColor: {
    type: String
  },
  fillOpacity: {
    type: Number
  },
  fillRule: {
    type: String
  },
  className: {
    type: String
  }
}, Ce = (t, o, e) => {
  const { options: n, methods: a } = Ve(t, o, e), s = L(
    t,
    ae,
    n
  ), l = m(oe), r = {
    ...a,
    setStroke(i) {
      o.value.setStyle({ stroke: i });
    },
    setColor(i) {
      o.value.setStyle({ color: i });
    },
    setWeight(i) {
      o.value.setStyle({ weight: i });
    },
    setOpacity(i) {
      o.value.setStyle({ opacity: i });
    },
    setLineCap(i) {
      o.value.setStyle({ lineCap: i });
    },
    setLineJoin(i) {
      o.value.setStyle({ lineJoin: i });
    },
    setDashArray(i) {
      o.value.setStyle({ dashArray: i });
    },
    setDashOffset(i) {
      o.value.setStyle({ dashOffset: i });
    },
    setFill(i) {
      o.value.setStyle({ fill: i });
    },
    setFillColor(i) {
      o.value.setStyle({ fillColor: i });
    },
    setFillOpacity(i) {
      o.value.setStyle({ fillOpacity: i });
    },
    setFillRule(i) {
      o.value.setStyle({ fillRule: i });
    },
    setClassName(i) {
      o.value.setStyle({ className: i });
    }
  };
  return J(() => {
    l({ leafletObject: o.value });
  }), { options: s, methods: r };
}, re = {
  ...ae,
  /**
   * Radius of the marker in pixels.
   */
  radius: {
    type: Number
  },
  latLng: {
    type: [Object, Array],
    required: !0,
    custom: !0
  }
}, Pe = (t, o, e) => {
  const { options: n, methods: a } = Ce(
    t,
    o,
    e
  ), s = L(
    t,
    re,
    n
  ), l = {
    ...a,
    setRadius(r) {
      o.value.setRadius(r);
    },
    setLatLng(r) {
      o.value.setLatLng(r);
    }
  };
  return { options: s, methods: l };
}, Be = {
  ...re,
  /**
   * Radius of the circle in meters.
   */
  radius: {
    type: Number
  }
}, xe = (t, o, e) => {
  const { options: n, methods: a } = Pe(t, o, e), s = L(
    t,
    Be,
    n
  ), l = {
    ...a
  };
  return { options: s, methods: l };
}, Ot = g({
  name: "LCircle",
  props: Be,
  setup(t, o) {
    const e = c(), n = c(!1), a = h(j), s = m(I), { options: l, methods: r } = xe(t, e, o);
    return O(async () => {
      const { circle: i } = a ? b.L : await import("leaflet/dist/leaflet-src.esm");
      e.value = C(i(t.latLng, l));
      const u = T(o.attrs);
      e.value.on(u), S(r, e.value, t), s({
        ...t,
        ...r,
        leafletObject: e.value
      }), n.value = !0, f(() => o.emit("ready", e.value));
    }), { ready: n, leafletObject: e };
  },
  render() {
    return M(this.ready, this.$slots);
  }
}), St = g({
  name: "LCircleMarker",
  props: re,
  setup(t, o) {
    const e = c(), n = c(!1), a = h(j), s = m(I), { options: l, methods: r } = Pe(
      t,
      e,
      o
    );
    return O(async () => {
      const { circleMarker: i } = a ? b.L : await import("leaflet/dist/leaflet-src.esm");
      e.value = C(
        i(t.latLng, l)
      );
      const u = T(o.attrs);
      e.value.on(u), S(r, e.value, t), s({
        ...t,
        ...r,
        leafletObject: e.value
      }), n.value = !0, f(() => o.emit("ready", e.value));
    }), { ready: n, leafletObject: e };
  },
  render() {
    return M(this.ready, this.$slots);
  }
}), H = {
  ...Q,
  position: {
    type: String
  }
}, V = (t, o) => {
  const { options: e, methods: n } = X(t), a = L(
    t,
    H,
    e
  ), s = {
    ...n,
    setPosition(l) {
      o.value && o.value.setPosition(l);
    }
  };
  return se(() => {
    o.value && o.value.remove();
  }), { options: a, methods: s };
}, Re = (t) => t.default ? z("div", { ref: "root" }, t.default()) : null, jt = g({
  name: "LControl",
  props: {
    ...H,
    disableClickPropagation: {
      type: Boolean,
      custom: !0,
      default: !0
    },
    disableScrollPropagation: {
      type: Boolean,
      custom: !0,
      default: !1
    }
  },
  setup(t, o) {
    const e = c(), n = c(), a = h(j), s = m(K), { options: l, methods: r } = V(t, e);
    return O(async () => {
      const { Control: i, DomEvent: u } = a ? b.L : await import("leaflet/dist/leaflet-src.esm"), d = i.extend({
        onAdd() {
          return n.value;
        }
      });
      e.value = C(new d(l)), S(r, e.value, t), s({ leafletObject: e.value }), t.disableClickPropagation && n.value && u.disableClickPropagation(n.value), t.disableScrollPropagation && n.value && u.disableScrollPropagation(n.value), f(() => o.emit("ready", e.value));
    }), { root: n, leafletObject: e };
  },
  render() {
    return Re(this.$slots);
  }
}), Te = {
  ...H,
  prefix: {
    type: String
  }
}, et = (t, o) => {
  const { options: e, methods: n } = V(
    t,
    o
  ), a = L(
    t,
    Te,
    e
  ), s = {
    ...n,
    setPrefix(l) {
      o.value.setPrefix(l);
    }
  };
  return { options: a, methods: s };
}, Ct = g({
  name: "LControlAttribution",
  props: Te,
  setup(t, o) {
    const e = c(), n = h(j), a = m(K), { options: s, methods: l } = et(t, e);
    return O(async () => {
      const { control: r } = n ? b.L : await import("leaflet/dist/leaflet-src.esm");
      e.value = C(
        r.attribution(s)
      ), S(l, e.value, t), a({ leafletObject: e.value }), f(() => o.emit("ready", e.value));
    }), { leafletObject: e };
  },
  render() {
    return null;
  }
}), we = {
  ...H,
  collapsed: {
    type: Boolean,
    default: void 0
  },
  autoZIndex: {
    type: Boolean,
    default: void 0
  },
  hideSingleBase: {
    type: Boolean,
    default: void 0
  },
  sortLayers: {
    type: Boolean,
    default: void 0
  },
  sortFunction: {
    type: Function
  }
}, tt = (t, o) => {
  const { options: e } = V(t, o);
  return { options: L(
    t,
    we,
    e
  ), methods: {
    addLayer(s) {
      s.layerType === "base" ? o.value.addBaseLayer(s.leafletObject, s.name) : s.layerType === "overlay" && o.value.addOverlay(s.leafletObject, s.name);
    },
    removeLayer(s) {
      o.value.removeLayer(s.leafletObject);
    }
  } };
}, Pt = g({
  name: "LControlLayers",
  props: we,
  setup(t, o) {
    const e = c(), n = h(j), a = m(ve), { options: s, methods: l } = tt(t, e);
    return O(async () => {
      const { control: r } = n ? b.L : await import("leaflet/dist/leaflet-src.esm");
      e.value = C(
        r.layers(void 0, void 0, s)
      ), S(l, e.value, t), a({
        ...t,
        ...l,
        leafletObject: e.value
      }), f(() => o.emit("ready", e.value));
    }), { leafletObject: e };
  },
  render() {
    return null;
  }
}), Ie = {
  ...H,
  maxWidth: {
    type: Number
  },
  metric: {
    type: Boolean,
    default: void 0
  },
  imperial: {
    type: Boolean,
    default: void 0
  },
  updateWhenIdle: {
    type: Boolean,
    default: void 0
  }
}, ot = (t, o) => {
  const { options: e, methods: n } = V(
    t,
    o
  );
  return { options: L(
    t,
    Ie,
    e
  ), methods: n };
}, Bt = g({
  name: "LControlScale",
  props: Ie,
  setup(t, o) {
    const e = c(), n = h(j), a = m(K), { options: s, methods: l } = ot(t, e);
    return O(async () => {
      const { control: r } = n ? b.L : await import("leaflet/dist/leaflet-src.esm");
      e.value = C(r.scale(s)), S(l, e.value, t), a({ leafletObject: e.value }), f(() => o.emit("ready", e.value));
    }), { leafletObject: e };
  },
  render() {
    return null;
  }
}), Ae = {
  ...H,
  zoomInText: {
    type: String
  },
  zoomInTitle: {
    type: String
  },
  zoomOutText: {
    type: String
  },
  zoomOutTitle: {
    type: String
  }
}, nt = (t, o) => {
  const { options: e, methods: n } = V(
    t,
    o
  );
  return { options: L(
    t,
    Ae,
    e
  ), methods: n };
}, Tt = g({
  name: "LControlZoom",
  props: Ae,
  setup(t, o) {
    const e = c(), n = h(j), a = m(K), { options: s, methods: l } = nt(t, e);
    return O(async () => {
      const { control: r } = n ? b.L : await import("leaflet/dist/leaflet-src.esm");
      e.value = C(r.zoom(s)), S(l, e.value, t), a({ leafletObject: e.value }), f(() => o.emit("ready", e.value));
    }), { leafletObject: e };
  },
  render() {
    return null;
  }
}), ne = {
  ...Z
}, le = (t, o, e) => {
  const { options: n, methods: a } = Y(
    t,
    o,
    e
  ), s = L(
    t,
    ne,
    n
  ), l = {
    ...a,
    addLayer(r) {
      o.value.addLayer(r.leafletObject);
    },
    removeLayer(r) {
      o.value.removeLayer(r.leafletObject);
    }
  };
  return G(I, l.addLayer), G(oe, l.removeLayer), { options: s, methods: l };
}, _e = {
  ...ne
}, st = (t, o, e) => {
  const { options: n, methods: a } = le(
    t,
    o,
    e
  ), s = L(
    t,
    _e,
    n
  ), l = {
    ...a
  };
  return { options: s, methods: l };
}, wt = g({
  props: _e,
  setup(t, o) {
    const e = c(), n = c(!1), a = h(j), s = m(I), { methods: l, options: r } = st(
      t,
      e,
      o
    );
    return O(async () => {
      const { featureGroup: i } = a ? b.L : await import("leaflet/dist/leaflet-src.esm");
      e.value = C(
        i(void 0, r)
      );
      const u = T(o.attrs);
      e.value.on(u), S(l, e.value, t), s({
        ...t,
        ...l,
        leafletObject: e.value
      }), n.value = !0, f(() => o.emit("ready", e.value));
    }), { ready: n, leafletObject: e };
  },
  render() {
    return M(this.ready, this.$slots);
  }
}), Ge = {
  ...ne,
  geojson: {
    type: [Object, Array],
    custom: !0
  },
  optionsStyle: {
    type: Function,
    custom: !0
  }
}, at = (t, o, e) => {
  const { options: n, methods: a } = le(
    t,
    o,
    e
  ), s = L(
    t,
    Ge,
    n
  );
  Object.prototype.hasOwnProperty.call(t, "optionsStyle") && (s.style = t.optionsStyle);
  const l = {
    ...a,
    setGeojson(r) {
      o.value.clearLayers(), o.value.addData(r);
    },
    setOptionsStyle(r) {
      o.value.setStyle(r);
    },
    getGeoJSONData() {
      return o.value.toGeoJSON();
    },
    getBounds() {
      return o.value.getBounds();
    }
  };
  return { options: s, methods: l };
}, It = g({
  props: Ge,
  setup(t, o) {
    const e = c(), n = c(!1), a = h(j), s = m(I), { methods: l, options: r } = at(t, e, o);
    return O(async () => {
      const { geoJSON: i } = a ? b.L : await import("leaflet/dist/leaflet-src.esm");
      e.value = C(i(t.geojson, r));
      const u = T(o.attrs);
      e.value.on(u), S(l, e.value, t), s({
        ...t,
        ...l,
        leafletObject: e.value
      }), n.value = !0, f(() => o.emit("ready", e.value));
    }), { ready: n, leafletObject: e };
  },
  render() {
    return M(this.ready, this.$slots);
  }
}), ie = {
  ...Z,
  opacity: {
    type: Number
  },
  zIndex: {
    type: Number
  },
  tileSize: {
    type: [Number, Array, Object]
  },
  noWrap: {
    type: Boolean,
    default: void 0
  },
  minZoom: {
    type: Number
  },
  maxZoom: {
    type: Number
  }
}, Me = (t, o, e) => {
  const { options: n, methods: a } = Y(
    t,
    o,
    e
  ), s = L(
    t,
    ie,
    n
  ), l = {
    ...a,
    setTileComponent() {
      var r;
      (r = o.value) == null || r.redraw();
    }
  };
  return se(() => {
    o.value.off();
  }), { options: s, methods: l };
}, rt = (t, o, e, n) => t.extend({
  initialize(a) {
    this.tileComponents = {}, this.on("tileunload", this._unloadTile), e.setOptions(this, a);
  },
  createTile(a) {
    const s = this._tileCoordsToKey(a);
    this.tileComponents[s] = o.create("div");
    const l = z({ setup: n, props: ["coords"] }, { coords: a });
    return Je(l, this.tileComponents[s]), this.tileComponents[s];
  },
  _unloadTile(a) {
    const s = this._tileCoordsToKey(a.coords);
    this.tileComponents[s] && (this.tileComponents[s].innerHTML = "", this.tileComponents[s] = void 0);
  }
}), At = g({
  props: {
    ...ie,
    childRender: {
      type: Function,
      required: !0
    }
  },
  setup(t, o) {
    const e = c(), n = c(null), a = c(!1), s = h(j), l = m(I), { options: r, methods: i } = Me(t, e, o);
    return O(async () => {
      const { GridLayer: u, DomUtil: d, Util: y } = s ? b.L : await import("leaflet/dist/leaflet-src.esm"), A = rt(
        u,
        d,
        y,
        t.childRender
      );
      e.value = C(new A(r));
      const v = T(o.attrs);
      e.value.on(v), S(i, e.value, t), l({
        ...t,
        ...i,
        leafletObject: e.value
      }), a.value = !0, f(() => o.emit("ready", e.value));
    }), { root: n, ready: a, leafletObject: e };
  },
  render() {
    return this.ready ? z("div", { style: { display: "none" }, ref: "root" }) : null;
  }
}), pe = {
  iconUrl: {
    type: String
  },
  iconRetinaUrl: {
    type: String
  },
  iconSize: {
    type: [Object, Array]
  },
  iconAnchor: {
    type: [Object, Array]
  },
  popupAnchor: {
    type: [Object, Array]
  },
  tooltipAnchor: {
    type: [Object, Array]
  },
  shadowUrl: {
    type: String
  },
  shadowRetinaUrl: {
    type: String
  },
  shadowSize: {
    type: [Object, Array]
  },
  shadowAnchor: {
    type: [Object, Array]
  },
  bgPos: {
    type: [Object, Array]
  },
  className: {
    type: String
  }
}, _t = g({
  name: "LIcon",
  props: {
    ...pe,
    ...Q
  },
  setup(t, o) {
    const e = c(), n = h(j), a = m(be), s = m(fe), l = m(Le);
    let r, i, u, d, y;
    const A = (w, _, k) => {
      const N = w && w.innerHTML;
      if (!_) {
        k && y && a() && s(N);
        return;
      }
      const D = T(o.attrs);
      y && i(y, D);
      const { options: E } = X(t), F = L(
        t,
        pe,
        E
      );
      N && (F.html = N), y = F.html ? u(F) : d(F), r(y, D), l(y);
    }, v = () => {
      f(() => A(e.value, !0, !1));
    }, $ = () => {
      f(() => A(e.value, !1, !0));
    }, B = {
      setIconUrl: v,
      setIconRetinaUrl: v,
      setIconSize: v,
      setIconAnchor: v,
      setPopupAnchor: v,
      setTooltipAnchor: v,
      setShadowUrl: v,
      setShadowRetinaUrl: v,
      setShadowAnchor: v,
      setBgPos: v,
      setClassName: v,
      setHtml: v
    };
    return O(async () => {
      const {
        DomEvent: w,
        divIcon: _,
        icon: k
      } = n ? b.L : await import("leaflet/dist/leaflet-src.esm");
      r = w.on, i = w.off, u = _, d = k, S(B, {}, t), new MutationObserver($).observe(e.value, {
        attributes: !0,
        childList: !0,
        characterData: !0,
        subtree: !0
      }), v();
    }), { root: e };
  },
  render() {
    const t = this.$slots.default ? this.$slots.default() : void 0;
    return z("div", { ref: "root" }, t);
  }
}), Ne = {
  ...Z,
  opacity: {
    type: Number
  },
  alt: {
    type: String
  },
  interactive: {
    type: Boolean,
    default: void 0
  },
  crossOrigin: {
    type: Boolean,
    default: void 0
  },
  errorOverlayUrl: {
    type: String
  },
  zIndex: {
    type: Number
  },
  className: {
    type: String
  },
  url: {
    type: String,
    required: !0,
    custom: !0
  },
  bounds: {
    type: [Array, Object],
    required: !0,
    custom: !0
  }
}, lt = (t, o, e) => {
  const { options: n, methods: a } = Y(
    t,
    o,
    e
  ), s = L(
    t,
    Ne,
    n
  ), l = {
    ...a,
    /**
     * Sets the opacity of the overlay.
     * @param {number} opacity
     */
    setOpacity(r) {
      return o.value.setOpacity(r);
    },
    /**
     * Changes the URL of the image.
     * @param {string} url
     */
    setUrl(r) {
      return o.value.setUrl(r);
    },
    /**
     * Update the bounds that this ImageOverlay covers
     * @param {LatLngBounds | Array<Array<number>>} bounds
     */
    setBounds(r) {
      return o.value.setBounds(r);
    },
    /**
     * Get the bounds that this ImageOverlay covers
     * @returns {LatLngBounds}
     */
    getBounds() {
      return o.value.getBounds();
    },
    /**
     * Returns the instance of HTMLImageElement used by this overlay.
     * @returns {HTMLElement}
     */
    getElement() {
      return o.value.getElement();
    },
    /**
     * Brings the layer to the top of all overlays.
     */
    bringToFront() {
      return o.value.bringToFront();
    },
    /**
     * Brings the layer to the bottom of all overlays.
     */
    bringToBack() {
      return o.value.bringToBack();
    },
    /**
     * Changes the zIndex of the image overlay.
     * @param {number} zIndex
     */
    setZIndex(r) {
      return o.value.setZIndex(r);
    }
  };
  return { options: s, methods: l };
}, Gt = g({
  name: "LImageOverlay",
  props: Ne,
  setup(t, o) {
    const e = c(), n = c(!1), a = h(j), s = m(I), { options: l, methods: r } = lt(
      t,
      e,
      o
    );
    return O(async () => {
      const { imageOverlay: i } = a ? b.L : await import("leaflet/dist/leaflet-src.esm");
      e.value = C(
        i(t.url, t.bounds, l)
      );
      const u = T(o.attrs);
      e.value.on(u), S(r, e.value, t), s({
        ...t,
        ...r,
        leafletObject: e.value
      }), n.value = !0, f(() => o.emit("ready", e.value));
    }), { ready: n, leafletObject: e };
  },
  render() {
    return M(this.ready, this.$slots);
  }
}), Mt = g({
  props: ne,
  setup(t, o) {
    const e = c(), n = c(!1), a = h(j), s = m(I), { methods: l } = le(t, e, o);
    return O(async () => {
      const { layerGroup: r } = a ? b.L : await import("leaflet/dist/leaflet-src.esm");
      e.value = C(
        r(void 0, t.options)
      );
      const i = T(o.attrs);
      e.value.on(i), S(l, e.value, t), s({
        ...t,
        ...l,
        leafletObject: e.value
      }), n.value = !0, f(() => o.emit("ready", e.value));
    }), { ready: n, leafletObject: e };
  },
  render() {
    return M(this.ready, this.$slots);
  }
});
function $e(t, o, e) {
  var n, a, s;
  o === void 0 && (o = 50), e === void 0 && (e = {});
  var l = (n = e.isImmediate) != null && n, r = (a = e.callback) != null && a, i = e.maxWait, u = Date.now(), d = [];
  function y() {
    if (i !== void 0) {
      var v = Date.now() - u;
      if (v + o >= i)
        return i - v;
    }
    return o;
  }
  var A = function() {
    var v = [].slice.call(arguments), $ = this;
    return new Promise(function(B, w) {
      var _ = l && s === void 0;
      if (s !== void 0 && clearTimeout(s), s = setTimeout(function() {
        if (s = void 0, u = Date.now(), !l) {
          var N = t.apply($, v);
          r && r(N), d.forEach(function(D) {
            return (0, D.resolve)(N);
          }), d = [];
        }
      }, y()), _) {
        var k = t.apply($, v);
        return r && r(k), B(k);
      }
      d.push({ resolve: B, reject: w });
    });
  };
  return A.cancel = function(v) {
    s !== void 0 && clearTimeout(s), d.forEach(function($) {
      return (0, $.reject)(v);
    }), d = [];
  }, A;
}
const ye = {
  ...Q,
  /**
   * The center of the map, supports .sync modifier
   */
  center: {
    type: [Object, Array]
  },
  /**
   * The bounds of the map, supports .sync modifier
   */
  bounds: {
    type: [Array, Object]
  },
  /**
   * The max bounds of the map
   */
  maxBounds: {
    type: [Array, Object]
  },
  /**
   * The zoom of the map, supports .sync modifier
   */
  zoom: {
    type: Number
  },
  /**
   * The minZoom of the map
   */
  minZoom: {
    type: Number
  },
  /**
   * The maxZoom of the map
   */
  maxZoom: {
    type: Number
  },
  /**
   * The paddingBottomRight of the map
   */
  paddingBottomRight: {
    type: [Object, Array]
  },
  /**
   * The paddingTopLeft of the map
   */
  paddingTopLeft: {
    type: Object
  },
  /**
   * The padding of the map
   */
  padding: {
    type: Object
  },
  /**
   * The worldCopyJump option for the map
   */
  worldCopyJump: {
    type: Boolean,
    default: void 0
  },
  /**
   * The CRS to use for the map. Can be an object that defines a coordinate reference
   * system for projecting geographical points into screen coordinates and back
   * (see https://leafletjs.com/reference-1.7.1.html#crs-l-crs-base), or a string
   * name identifying one of Leaflet's defined CRSs, such as "EPSG4326".
   */
  crs: {
    type: [String, Object]
  },
  maxBoundsViscosity: {
    type: Number
  },
  inertia: {
    type: Boolean,
    default: void 0
  },
  inertiaDeceleration: {
    type: Number
  },
  inertiaMaxSpeed: {
    type: Number
  },
  easeLinearity: {
    type: Number
  },
  zoomAnimation: {
    type: Boolean,
    default: void 0
  },
  zoomAnimationThreshold: {
    type: Number
  },
  fadeAnimation: {
    type: Boolean,
    default: void 0
  },
  markerZoomAnimation: {
    type: Boolean,
    default: void 0
  },
  noBlockingAnimations: {
    type: Boolean,
    default: void 0
  },
  useGlobalLeaflet: {
    type: Boolean,
    default: !0,
    custom: !0
  }
}, Nt = g({
  emits: ["ready", "update:zoom", "update:center", "update:bounds"],
  props: ye,
  setup(t, o) {
    const e = c(), n = Ke({
      ready: !1,
      layersToAdd: [],
      layersInControl: []
    }), { options: a } = X(t), s = L(
      t,
      ye,
      a
    ), l = R(I), r = R(oe), i = R(K), u = R(
      ve
    );
    G(j, t.useGlobalLeaflet);
    const d = x(() => {
      const B = {};
      return t.noBlockingAnimations && (B.animate = !1), B;
    }), y = x(() => {
      const B = d.value;
      return t.padding && (B.padding = t.padding), t.paddingTopLeft && (B.paddingTopLeft = t.paddingTopLeft), t.paddingBottomRight && (B.paddingBottomRight = t.paddingBottomRight), B;
    }), A = {
      moveend: $e((B) => {
        n.leafletRef && (o.emit("update:zoom", n.leafletRef.getZoom()), o.emit("update:center", n.leafletRef.getCenter()), o.emit("update:bounds", n.leafletRef.getBounds()));
      }),
      overlayadd(B) {
        const w = n.layersInControl.find((_) => _.name === B.name);
        w && w.updateVisibleProp(!0);
      },
      overlayremove(B) {
        const w = n.layersInControl.find((_) => _.name === B.name);
        w && w.updateVisibleProp(!1);
      }
    };
    O(async () => {
      t.useGlobalLeaflet && (b.L = b.L || await import("leaflet"));
      const {
        map: B,
        CRS: w,
        Icon: _,
        latLngBounds: k,
        latLng: N,
        DomEvent: D,
        stamp: E
      } = t.useGlobalLeaflet ? b.L : await import("leaflet/dist/leaflet-src.esm");
      try {
        s.beforeMapMount && await s.beforeMapMount();
      } catch (p) {
        console.error(
          `The following error occurred running the provided beforeMapMount hook ${p.message}`
        );
      }
      await Ye(_);
      const F = typeof s.crs == "string" ? w[s.crs] : s.crs;
      s.crs = F || w.EPSG3857;
      const W = {
        addLayer(p) {
          p.layerType !== void 0 && (n.layerControl === void 0 ? n.layersToAdd.push(p) : n.layersInControl.find(
            (q) => E(q.leafletObject) === E(p.leafletObject)
          ) || (n.layerControl.addLayer(p), n.layersInControl.push(p))), p.visible !== !1 && n.leafletRef.addLayer(p.leafletObject);
        },
        removeLayer(p) {
          p.layerType !== void 0 && (n.layerControl === void 0 ? n.layersToAdd = n.layersToAdd.filter(
            (P) => P.name !== p.name
          ) : (n.layerControl.removeLayer(p.leafletObject), n.layersInControl = n.layersInControl.filter(
            (P) => E(P.leafletObject) !== E(p.leafletObject)
          ))), n.leafletRef.removeLayer(p.leafletObject);
        },
        registerLayerControl(p) {
          n.layerControl = p, n.layersToAdd.forEach((P) => {
            n.layerControl.addLayer(P);
          }), n.layersToAdd = [], i(p);
        },
        registerControl(p) {
          n.leafletRef.addControl(p.leafletObject);
        },
        setZoom(p) {
          const P = n.leafletRef.getZoom();
          p !== P && n.leafletRef.setZoom(p, d.value);
        },
        setCrs(p) {
          const P = n.leafletRef.getBounds();
          n.leafletRef.options.crs = p, n.leafletRef.fitBounds(P, {
            animate: !1,
            padding: [0, 0]
          });
        },
        fitBounds(p) {
          n.leafletRef.fitBounds(p, y.value);
        },
        setBounds(p) {
          if (!p)
            return;
          const P = k(p);
          if (!P.isValid())
            return;
          !(n.lastSetBounds || n.leafletRef.getBounds()).equals(P, 0) && (n.lastSetBounds = P, n.leafletRef.fitBounds(P));
        },
        setCenter(p) {
          if (p == null)
            return;
          const P = N(p), q = n.lastSetCenter || n.leafletRef.getCenter();
          (q.lat !== P.lat || q.lng !== P.lng) && (n.lastSetCenter = P, n.leafletRef.panTo(P, d.value));
        }
      };
      ee(l, W.addLayer), ee(r, W.removeLayer), ee(i, W.registerControl), ee(u, W.registerLayerControl), n.leafletRef = C(B(e.value, s)), S(W, n.leafletRef, t);
      const qe = T(o.attrs);
      Qe(n.leafletRef, A), D.on(n.leafletRef.getContainer(), qe), n.ready = !0, f(() => o.emit("ready", n.leafletRef));
    }), J(() => {
      me(A), n.leafletRef && (n.leafletRef.off(), n.leafletRef.remove());
    });
    const v = x(() => n.leafletRef), $ = x(() => n.ready);
    return { root: e, ready: $, leafletObject: v };
  },
  render() {
    return z(
      "div",
      { style: { width: "100%", height: "100%" }, ref: "root" },
      this.ready && this.$slots.default ? this.$slots.default() : {}
    );
  }
}), it = ["Symbol(Comment)", "Symbol(Text)"], ut = ["LTooltip", "LPopup"], ke = {
  ...Z,
  draggable: {
    type: Boolean,
    default: void 0
  },
  icon: {
    type: [Object]
  },
  zIndexOffset: {
    type: Number
  },
  latLng: {
    type: [Object, Array],
    custom: !0,
    required: !0
  }
}, ct = (t, o, e) => {
  const { options: n, methods: a } = Y(
    t,
    o,
    e
  ), s = L(
    t,
    ke,
    n
  ), l = {
    ...a,
    setDraggable(r) {
      o.value.dragging && (r ? o.value.dragging.enable() : o.value.dragging.disable());
    },
    latLngSync(r) {
      e.emit("update:latLng", r.latlng), e.emit("update:lat-lng", r.latlng);
    },
    setLatLng(r) {
      if (r != null && o.value) {
        const i = o.value.getLatLng();
        (!i || !i.equals(r)) && o.value.setLatLng(r);
      }
    }
  };
  return { options: s, methods: l };
}, dt = (t, o) => {
  const e = o.slots.default && o.slots.default();
  return e && e.length && e.some(pt);
};
function pt(t) {
  return !(it.includes(t.type.toString()) || ut.includes(t.type.name));
}
const $t = g({
  name: "LMarker",
  props: ke,
  setup(t, o) {
    const e = c(), n = c(!1), a = h(j), s = m(I);
    G(
      be,
      () => {
        var u;
        return !!((u = e.value) != null && u.getElement());
      }
    ), G(fe, (u) => {
      var y, A;
      const d = U((y = e.value) == null ? void 0 : y.getElement) && ((A = e.value) == null ? void 0 : A.getElement());
      d && (d.innerHTML = u);
    }), G(
      Le,
      (u) => {
        var d;
        return ((d = e.value) == null ? void 0 : d.setIcon) && e.value.setIcon(u);
      }
    );
    const { options: l, methods: r } = ct(t, e, o), i = {
      moveHandler: $e(r.latLngSync)
    };
    return O(async () => {
      const { marker: u, divIcon: d } = a ? b.L : await import("leaflet/dist/leaflet-src.esm");
      dt(l, o) && (l.icon = d({ className: "" })), e.value = C(u(t.latLng, l));
      const y = T(o.attrs);
      e.value.on(y), e.value.on("move", i.moveHandler), S(r, e.value, t), s({
        ...t,
        ...r,
        leafletObject: e.value
      }), n.value = !0, f(() => o.emit("ready", e.value));
    }), J(() => me(i)), { ready: n, leafletObject: e };
  },
  render() {
    return M(this.ready, this.$slots);
  }
}), ue = {
  ...ae,
  smoothFactor: {
    type: Number
  },
  noClip: {
    type: Boolean,
    default: void 0
  },
  latLngs: {
    type: Array,
    required: !0,
    custom: !0
  }
}, Ue = (t, o, e) => {
  const { options: n, methods: a } = Ce(
    t,
    o,
    e
  ), s = L(
    t,
    ue,
    n
  ), l = {
    ...a,
    setSmoothFactor(r) {
      o.value.setStyle({ smoothFactor: r });
    },
    setNoClip(r) {
      o.value.setStyle({ noClip: r });
    },
    addLatLng(r) {
      o.value.addLatLng(r);
    }
  };
  return { options: s, methods: l };
}, te = {
  ...ue
}, ze = (t, o, e) => {
  const { options: n, methods: a } = Ue(
    t,
    o,
    e
  ), s = L(
    t,
    te,
    n
  ), l = {
    ...a,
    toGeoJSON(r) {
      return o.value.toGeoJSON(r);
    }
  };
  return { options: s, methods: l };
}, kt = g({
  name: "LPolygon",
  props: te,
  setup(t, o) {
    const e = c(), n = c(!1), a = h(j), s = m(I), { options: l, methods: r } = ze(t, e, o);
    return O(async () => {
      const { polygon: i } = a ? b.L : await import("leaflet/dist/leaflet-src.esm");
      e.value = C(i(t.latLngs, l));
      const u = T(o.attrs);
      e.value.on(u), S(r, e.value, t), s({
        ...t,
        ...r,
        leafletObject: e.value
      }), n.value = !0, f(() => o.emit("ready", e.value));
    }), { ready: n, leafletObject: e };
  },
  render() {
    return M(this.ready, this.$slots);
  }
}), Ut = g({
  name: "LPolyline",
  props: ue,
  setup(t, o) {
    const e = c(), n = c(!1), a = h(j), s = m(I), { options: l, methods: r } = Ue(t, e, o);
    return O(async () => {
      const { polyline: i } = a ? b.L : await import("leaflet/dist/leaflet-src.esm");
      e.value = C(
        i(t.latLngs, l)
      );
      const u = T(o.attrs);
      e.value.on(u), S(r, e.value, t), s({
        ...t,
        ...r,
        leafletObject: e.value
      }), n.value = !0, f(() => o.emit("ready", e.value));
    }), { ready: n, leafletObject: e };
  },
  render() {
    return M(this.ready, this.$slots);
  }
}), De = {
  ...Q,
  content: {
    type: String,
    default: null
  }
}, Ee = (t, o) => {
  const { options: e, methods: n } = X(t), a = {
    ...n,
    setContent(s) {
      o.value && s !== null && s !== void 0 && o.value.setContent(s);
    }
  };
  return { options: e, methods: a };
}, Fe = (t) => t.default ? z("div", { ref: "root" }, t.default()) : null, yt = {
  ...De,
  latLng: {
    type: [Object, Array],
    default: () => []
  }
}, mt = (t, o) => {
  const { options: e, methods: n } = Ee(t, o);
  return { options: e, methods: n };
}, zt = g({
  name: "LPopup",
  props: yt,
  setup(t, o) {
    const e = c(), n = c(null), a = h(j), s = m(he), l = m(Oe), { options: r, methods: i } = mt(t, e);
    return O(async () => {
      const { popup: u } = a ? b.L : await import("leaflet/dist/leaflet-src.esm");
      e.value = C(u(r)), t.latLng !== void 0 && e.value.setLatLng(t.latLng), S(i, e.value, t);
      const d = T(o.attrs);
      e.value.on(d), e.value.setContent(t.content || n.value || ""), s(e.value), f(() => o.emit("ready", e.value));
    }), J(() => {
      l();
    }), { root: n, leafletObject: e };
  },
  render() {
    return Fe(this.$slots);
  }
}), Ze = {
  ...te,
  latLngs: {
    ...te.latLngs,
    required: !1
  },
  bounds: {
    type: Object,
    custom: !0
  }
}, vt = (t, o, e) => {
  const { options: n, methods: a } = ze(
    t,
    o,
    e
  ), s = L(
    t,
    Ze,
    n
  ), l = {
    ...a,
    setBounds(r) {
      o.value.setBounds(r);
    },
    setLatLngs(r) {
      o.value.setBounds(r);
    }
  };
  return { options: s, methods: l };
}, Dt = g({
  name: "LRectangle",
  props: Ze,
  setup(t, o) {
    const e = c(), n = c(!1), a = h(j), s = m(I), { options: l, methods: r } = vt(t, e, o);
    return O(async () => {
      const { rectangle: i, latLngBounds: u } = a ? b.L : await import("leaflet/dist/leaflet-src.esm"), d = t.bounds ? u(t.bounds) : u(t.latLngs || []);
      e.value = C(i(d, l));
      const y = T(o.attrs);
      e.value.on(y), S(r, e.value, t), s({
        ...t,
        ...r,
        leafletObject: e.value
      }), n.value = !0, f(() => o.emit("ready", e.value));
    }), { ready: n, leafletObject: e };
  },
  render() {
    return M(this.ready, this.$slots);
  }
}), ce = {
  ...ie,
  tms: {
    type: Boolean,
    default: void 0
  },
  subdomains: {
    type: [String, Array],
    validator: (t) => typeof t == "string" ? !0 : Array.isArray(t) ? t.every((o) => typeof o == "string") : !1
  },
  detectRetina: {
    type: Boolean,
    default: void 0
  },
  url: {
    type: String,
    required: !0,
    custom: !0
  }
}, He = (t, o, e) => {
  const { options: n, methods: a } = Me(t, o, e), s = L(
    t,
    ce,
    n
  ), l = {
    ...a
  };
  return { options: s, methods: l };
}, Et = g({
  props: ce,
  setup(t, o) {
    const e = c(), n = h(j), a = m(I), { options: s, methods: l } = He(t, e, o);
    return O(async () => {
      const { tileLayer: r } = n ? b.L : await import("leaflet/dist/leaflet-src.esm");
      e.value = C(r(t.url, s));
      const i = T(o.attrs);
      e.value.on(i), S(l, e.value, t), a({
        ...t,
        ...l,
        leafletObject: e.value
      }), f(() => o.emit("ready", e.value));
    }), { leafletObject: e };
  },
  render() {
    return null;
  }
}), bt = {
  ...De
}, ft = (t, o) => {
  const { options: e, methods: n } = Ee(t, o), a = m(Se);
  return J(() => {
    a();
  }), { options: e, methods: n };
}, Ft = g({
  name: "LTooltip",
  props: bt,
  setup(t, o) {
    const e = c(), n = c(null), a = h(j), s = m(ge), { options: l, methods: r } = ft(t, e);
    return O(async () => {
      const { tooltip: i } = a ? b.L : await import("leaflet/dist/leaflet-src.esm");
      e.value = C(i(l)), S(r, e.value, t);
      const u = T(o.attrs);
      e.value.on(u), e.value.setContent(t.content || n.value || ""), s(e.value), f(() => o.emit("ready", e.value));
    }), { root: n, leafletObject: e };
  },
  render() {
    return Fe(this.$slots);
  }
}), We = {
  ...ce,
  layers: {
    type: String,
    required: !0
  },
  styles: {
    type: String
  },
  format: {
    type: String
  },
  transparent: {
    type: Boolean,
    default: void 0
  },
  version: {
    type: String
  },
  crs: {
    type: Object
  },
  uppercase: {
    type: Boolean,
    default: void 0
  }
}, Lt = (t, o, e) => {
  const { options: n, methods: a } = He(t, o, e);
  return {
    options: L(
      t,
      We,
      n
    ),
    methods: {
      ...a
    }
  };
}, Zt = g({
  props: We,
  setup(t, o) {
    const e = c(), n = h(j), a = m(I), { options: s, methods: l } = Lt(
      t,
      e,
      o
    );
    return O(async () => {
      const { tileLayer: r } = n ? b.L : await import("leaflet/dist/leaflet-src.esm");
      e.value = C(
        r.wms(t.url, s)
      );
      const i = T(o.attrs);
      e.value.on(i), S(l, e.value, t), a({
        ...t,
        ...l,
        leafletObject: e.value
      }), f(() => o.emit("ready", e.value));
    }), { leafletObject: e };
  },
  render() {
    return null;
  }
});
export {
  Ot as LCircle,
  St as LCircleMarker,
  jt as LControl,
  Ct as LControlAttribution,
  Pt as LControlLayers,
  Bt as LControlScale,
  Tt as LControlZoom,
  wt as LFeatureGroup,
  It as LGeoJson,
  At as LGridLayer,
  _t as LIcon,
  Gt as LImageOverlay,
  Mt as LLayerGroup,
  Nt as LMap,
  $t as LMarker,
  kt as LPolygon,
  Ut as LPolyline,
  zt as LPopup,
  Dt as LRectangle,
  Et as LTileLayer,
  Ft as LTooltip,
  Zt as LWmsTileLayer
};
